"use strict";(self.webpackChunkoc_studio_docs=self.webpackChunkoc_studio_docs||[]).push([[3562],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return x}});var o=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,s=function(e,n){if(null==e)return{};var t,o,s={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var l=o.createContext({}),u=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},c=function(e){var n=u(e.components);return o.createElement(l.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(t),m=s,x=p["".concat(l,".").concat(m)]||p[m]||d[m]||r;return t?o.createElement(x,a(a({ref:n},c),{},{components:t})):o.createElement(x,a({ref:n},c))}));function x(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=t.length,a=new Array(r);a[0]=m;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[p]="string"==typeof e?e:s,a[1]=i;for(var u=2;u<r;u++)a[u]=t[u];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2256:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return l},default:function(){return x},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return p}});var o=t(7462),s=t(3366),r=(t(7294),t(3905)),a=["components"],i={title:"PostText Lambda"},l=void 0,u={unversionedId:"development/posttext-lambda",id:"development/posttext-lambda",title:"PostText Lambda",description:"The PostText Lambda is named after the Amazon Lex API PostText which is used to turn a natural language query into an intent and slots.",source:"@site/docs/development/posttext-lambda.md",sourceDirName:"development",slug:"/development/posttext-lambda",permalink:"/docs/development/posttext-lambda",draft:!1,editUrl:"https://github.com/xapp-ai/documentation/edit/main/docs/development/posttext-lambda.md",tags:[],version:"current",frontMatter:{title:"PostText Lambda"}},c={},p=[{value:"Source Code",id:"source-code",level:3}],d={toc:p},m="wrapper";function x(e){var n=e.components,i=(0,s.Z)(e,a);return(0,r.kt)(m,(0,o.Z)({},d,i,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The PostText Lambda is named after the Amazon Lex API ",(0,r.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/lex/latest/dg/API_runtime_PostText.html"},"PostText")," which is used to turn a natural language query into an intent and slots."),(0,r.kt)("p",null,"This Lambda sits behind APIGateway and will receive messages from the chat widget and will call the PostText API if a natural language query needs to be translated to an intent or pass it straight to the runtime lambda."),(0,r.kt)("p",null,"When it calls the PostText API, it is Lex that then calls the App Lambda and the response is returned in the response to the PostText API call."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"posttext-lambda",src:t(5018).Z,width:"578",height:"367"})),(0,r.kt)("h3",{id:"source-code"},"Source Code"),(0,r.kt)("p",null,"You can setup your own PostText Lambda as part of your project and deployment process.  Alternatively you can upload to your own Lambda with the archive ",(0,r.kt)("a",{parentName:"p",href:"https://xapp-ai-deployment.s3.amazonaws.com/posttext.zip"},"here"),", this same archive is used by some of our deployment scripts."),(0,r.kt)("p",null,"Make sure you add the following dependencies to your ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'  "dependencies": {\n    "@xapp/stentor-lex-lib": "1.45.32",\n    "stentor-constants": "1.57.95",\n    "stentor-interaction-model": "1.57.95",\n    "stentor-locales": "1.57.95",\n    "stentor-models": "1.57.95",\n    "stentor-request": "1.57.95",\n    "stentor-utils": "1.57.95"\n  }\n')),(0,r.kt)("p",null,"Then for the handler of the Lambda:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import {\n    TranslateLexPostTextResponse,\n    TranslateLexV2PostTextResponse,\n    TranslateToLexPostTextRequest,\n    TranslateToLexV2PostTextRequest\n} from "@xapp/stentor-lex-lib";\nimport { Lambda, LexRuntime, LexRuntimeV2 } from "aws-sdk";\nimport { ActiveContext, Request, Response } from "stentor-models";\n\n/**\n * A common Context object for lambdas.\n */\nexport type AWSApiGatewayLambdaContext = LambdaContext;\n\nexport interface LambdaContext {\n    callbackWaitsForEmptyEventLoop?: boolean;\n    logGroupName?: string;\n    logStreamName?: string;\n    functionName?: string;\n    memoryLimitInMB?: string;\n    functionVersion?: number;\n    awsRequestId?: string;\n    invokedFunctionArn?: string;\n}\n\nexport const LEX_BOT = process.env.LEX_BOT;\nexport const LEX_BOT_ID = process.env.LEX_BOT_ID;\nexport const LEX_BOT_LOCALE = process.env.LEX_BOT_LOCALE;\nexport const LEX_BOT_VERSION = process.env.LEX_BOT_VERSION;\nexport const LEX_BOT_ALIAS = process.env.LEX_BOT_ALIAS;\nexport const LEX_BOT_ALIAS_ID = process.env.LEX_BOT_ALIAS_ID;\n\nexport const OCSTUDIO_ARN = process.env.OC_STUDIO_ARN;\nconst LambdaArnSplit = OCSTUDIO_ARN.split(":");\nconst OCSTUDIO_NAME = LambdaArnSplit[LambdaArnSplit.length - 1];\n\nexport type BaseEvent = Request;\n\nexport interface APIGatewayEvent {\n    body?: string;\n}\n\nexport type Event = BaseEvent | APIGatewayEvent;\n\nconst lambda = new Lambda();\n\nconst lex = new LexRuntime();\nconst requestTranslator = new TranslateToLexPostTextRequest();\nconst responseTranslator = new TranslateLexPostTextResponse();\n\nconst lexV2 = new LexRuntimeV2();\nconst requestV2Translator = new TranslateToLexV2PostTextRequest();\nconst responseV2Translator = new TranslateLexV2PostTextResponse();\n\nexport async function handler(event: any, context: LambdaContext) {\n    const translatorRequest = getTranslatorRequest(event);\n\n    let sessionId;\n    let userId;\n\n    // We only want this request to be handled by PostText if there\'s an inputText.\n    // Otherwise the Studio handler will take care of the request.\n    if (LEX_BOT_VERSION === "v2") {\n        const lexV2Request = requestV2Translator.translate(translatorRequest);\n\n        // We will need a session id in Lex V2\n        sessionId = lexV2Request.sessionId;\n\n        if (lexV2Request.text) {\n            return lexV2.recognizeText({\n                ...lexV2Request,\n                botId: LEX_BOT_ID,\n                botAliasId: LEX_BOT_ALIAS_ID,\n                localeId: LEX_BOT_LOCALE\n            }).promise()\n                .then((lexResponse: any) => responseV2Translator.translate(lexResponse))\n                .then((response: any) => getHandlerReturnValue(event, response));\n        }\n    } else {\n        const lexRequest = requestTranslator.translate(translatorRequest);\n\n        userId = lexRequest.userId;\n\n        if (lexRequest.inputText) {\n            return lex.postText({\n                botName: LEX_BOT,\n                botAlias:  LEX_BOT_ALIAS || "latest",\n                userId: "TestUserId",\n                ...lexRequest\n            }).promise()\n                .then((lexResponse: any) => responseTranslator.translate(lexResponse))\n                .then((response: any) => getHandlerReturnValue(event, response));\n        }\n    }\n\n    let response: Response;\n\n    await lambda.invoke({\n        FunctionName: OCSTUDIO_NAME,\n        Payload: JSON.stringify(event)\n    }).promise().then((result: any) => {\n        response = JSON.parse(JSON.parse(result.Payload).body) as Response; // Stentor response\n    });\n\n    if (response.context) {\n        if (LEX_BOT_VERSION === "v2") {\n            const putSessionV2Request: LexRuntimeV2.PutSessionRequest = {\n                botId: LEX_BOT_ID,\n                botAliasId: LEX_BOT_ALIAS_ID,\n                localeId: LEX_BOT_LOCALE,\n                sessionId,\n                sessionState: {\n                    activeContexts: convertV2ActiveContext(response.context.active)\n                }\n            };\n\n            await lexV2.putSession(putSessionV2Request).promise();\n        } else {\n            // In Lex V1 the name/alias/user identifies the conversation aka. session\n            const putSessionRequest: LexRuntime.PutSessionRequest = {\n                botName: LEX_BOT,\n                botAlias:  LEX_BOT_ALIAS || "latest",\n                userId: userId || "TestUserId",\n                activeContexts: convertActiveContext(response.context.active)\n            };\n\n            await lex.putSession(putSessionRequest).promise();\n        }\n    }\n\n    return getHandlerReturnValue(event, response);\n}\n\nfunction getHandlerReturnValue(event: Event, response: object): object {\n    if (isApiGatewayEvent(event)) {\n        return {\n            statusCode: 200,\n            body: JSON.stringify(response),\n            headers: {\n                "Content-Type": "application/json",\n                "Access-Control-Allow-Origin": "*"\n            }\n        };\n    }\n    return response;\n}\n\nfunction getTranslatorRequest(event: Event): Request {\n    if (isApiGatewayEvent(event)) {\n        try {\n            return JSON.parse(event.body);\n        } catch (e) {\n            console.error("Could not parse body", event.body, e);\n            throw new Error("Invalid API Gateway input body.");\n        }\n    }\n    return event;\n}\n\nfunction isApiGatewayEvent(event: Event): event is APIGatewayEvent  {\n    return !!(event as APIGatewayEvent).body;\n}\n\nfunction convertActiveContext(active: ActiveContext[]): LexRuntime.ActiveContext[] {\n    if (!active || active.length === 0) return [];\n\n    return active.map((value, index) => {\n        return {\n            name: value.name,\n            timeToLive: value.timeToLive,\n            parameters: value.parameters || {}\n        };\n    });\n}\n\nfunction convertV2ActiveContext(active: ActiveContext[]): LexRuntimeV2.ActiveContext[] {\n    if (!active || active.length === 0) return [];\n\n    return active.map((value, index) => {\n        return {\n            name: value.name,\n            timeToLive: {\n                timeToLiveInSeconds: value.timeToLive?.timeToLiveInSeconds,\n                turnsToLive: value.timeToLive?.turnsToLive\n            },\n            contextAttributes: value.parameters || {}\n        };\n    });\n}\n')))}x.isMDXComponent=!0},5018:function(e,n,t){n.Z=t.p+"assets/images/posttext-lambda-c16fc35a58ed251a52f1d0e51ada924c.png"}}]);